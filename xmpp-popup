#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import division

import sys

from twisted.internet import gtk3reactor
gtk3reactor.install()

from twisted.application import service
from twisted.words.protocols.jabber.jid import JID
from twisted.python import log

from wokkel import client
from wokkel.xmppim import (
    RosterClientProtocol, PresenceClientProtocol, MessageProtocol)

from gi.repository import Gtk, Gdk, GLib


class XMPPPopupApplication(Gtk.Application):
    def on_activate(self, evt):
        pass

    def run(self, argv):
        self.connect('activate', self.on_activate)
        return super(Gtk.Application, self).run(argv)


class MessageShowManager(object):
    def __init__(self, options):
        # first in, first out
        self.message_windows = []

        window = Gtk.Window()
        screen = window.get_screen()
        self.screen_height = screen.get_height()
        self.screen_width = screen.get_width()

        self.options = options

    def show_message(self, sender, body):
        win = Gtk.Window(title="Lecture message")

        frame = Gtk.Frame()
        win.add(frame)
        frame.set_shadow_type(Gtk.ShadowType.OUT)

        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        vbox.set_margin_top(10)
        vbox.set_margin_left(10)
        vbox.set_margin_bottom(10)
        vbox.set_margin_right(10)
        frame.add(vbox)

        label = Gtk.Label()
        label.set_markup(
            '<span font_desc="10"><i>%s:</i></span>\n'
            '<span font_desc="20">%s</span>'
            % (sender, body))

        buttonbox = Gtk.Box(spacing=10)

        if self.options.popup_timeout:
            keep_button = Gtk.Button(label="Keep")
            buttonbox.add(keep_button)

        close_all_button = Gtk.Button(label="Close all")
        buttonbox.pack_end(close_all_button, expand=False, fill=False, padding=0)

        close_button = Gtk.Button(label="Close")
        buttonbox.pack_end(close_button, expand=False, fill=False, padding=0)

        vbox.add(label)

        if self.options.popup_timeout:
            bar = Gtk.ProgressBar()
            vbox.add(bar)

        vbox.add(buttonbox)

        win.set_gravity(Gdk.Gravity.SOUTH_EAST)
        win.set_type_hint(Gdk.WindowTypeHint.NOTIFICATION)
        win.set_decorated(False)
        win.set_urgency_hint(True)
        win.show_all()

        self.message_windows.insert(0, win)
        self.relayout()

        # {{{ window behavior

        def keep_win(evt):
            if timer:
                vbox.remove(bar)
                del timer[0]

        def remove_win(evt):
            self.remove_window(win)

        def remove_all(evt):
            self.remove_all()

        TIMER_INCREMENT = 10

        def tick_timer():
            if not timer:
                return

            timer[0] += TIMER_INCREMENT
            bar.set_fraction(timer[0]/self.options.popup_timeout)
            if timer[0] > self.options.popup_timeout:
                self.remove_window(win)
                return

            timer_id[0] = GLib.timeout_add(TIMER_INCREMENT*1000, tick_timer)

        if self.options.popup_timeout:
            keep_button.connect("clicked", keep_win)

        close_button.connect("clicked", remove_win)
        close_all_button.connect("clicked", remove_all)

        if self.options.popup_timeout:
            timer = [0]
            timer_id = [GLib.timeout_add(TIMER_INCREMENT*1000, tick_timer)]
        else:
            timer = []

        # }}}

    def relayout(self):
        bottom = self.screen_height

        for win in self.message_windows:
            w, h = win.get_size()
            bottom -= h
            win.move(self.screen_width, bottom)
            win.present()

    def remove_window(self, win):
        found = False
        for i, w in enumerate(self.message_windows):
            if w is win:
                self.message_windows.pop(i)
                found = True
                break

        if not found:
            return

        win.destroy()
        self.relayout()

    def remove_all(self):
        for w in self.message_windows:
            w.destroy()

        del self.message_windows[:]


class ConversationManager(object):
    def __init__(self, mshow_mgr, jid, options):
        self.mshow_mgr = mshow_mgr
        self.jid = jid
        self.options = options

        import sqlite3 as sqlite
        if options.reg_db is not None:
            self.db_conn = sqlite.connect(options.reg_db, timeout=30)

            try:
                self.db_conn.execute("select * from registrations;")
            except sqlite.OperationalError:
                self.db_conn.execute("""
                      create table registrations (
                        id integer primary key autoincrement,
                        jid text,
                        email text,
                        reg_code text)
                        """)
                # reg_code is null means successfully registered

        else:
            self.db_conn = None

    def message_received(self, msg):
        if msg["type"] == 'chat' and hasattr(msg, "body"):
            if self.db_conn is None:
                self.mshow_mgr.show_message(msg["from"], msg.body)

            bare_jid = JID(msg["from"]).userhost()
            import re

            # {{{ handle reg message

            reg_match = re.match("^reg (.*)$", unicode(msg.body))
            if reg_match is not None:
                self.db_conn.execute(
                    "delete from registrations where jid = ?", (bare_jid, ))

                email = reg_match.group(1)
                if not email.endswith(self.options.required_email_suffix):
                    from twisted.words.xish import domish
                    msg = domish.Element((None, "message"))
                    msg["to"] = msg["from"]
                    msg["from"] = self.jid.full()
                    msg["type"] = 'chat'

                    msg.addElement("body", content="Your email must end in '%s'."
                                % self.options.required_email_suffix)

                    self.message_protocol.send(msg)
                    return

                import random
                reg_code = "".join(random.choice("0123456789") for i in range(6))

                self.db_conn.execute(
                    "insert into registrations (jid, email, reg_code) "
                    "values (?, ?, ?)", (bare_jid, reg_code, email))

                from email.mime.text import MIMEText
                from subprocess import Popen, PIPE

                msg = MIMEText("Hi there,\n\n"
                        "please send 'code %s' (minus the quotes) to '%s' "
                        "(via chat) to complete your "
                        "registration for the instant feedback system.\n\nThanks!"
                        % (reg_code, self.jid.userhost()))

                if self.options.sender_email is None:
                    from_email = self.jid.userhost()
                else:
                    from_email = self.options.sender_email

                msg["From"] = from_email
                msg["To"] = email
                msg["Subject"] = "Registration code for instant feedback system"
                p = Popen(["/usr/sbin/sendmail", "-t"], stdin=PIPE)
                p.communicate(msg.as_string())

            # }}}

    def presence_received(self, entity):
        from twisted.words.xish import domish
        msg = domish.Element((None, "message"))
        msg["to"] = entity.full()
        msg["from"] = self.jid.full()
        msg["type"] = 'chat'
        greeting = ("Welcome to the instant feedback system! "
                "Please say 'reg my@email.address' (without quotes) to register. ")

        if self.options.required_email_suffix is not None:
            greeting += "Your email must end in '%s'." \
                    % self.options.required_email_suffix

        msg.addElement("body", content=greeting)

        self.message_protocol.send(msg)


# {{{ jabber handlers

class MessageReceiver(MessageProtocol):
    def __init__(self, conversation_mgr):
        self.conversation_mgr = conversation_mgr
        conversation_mgr.message_protocol = self

    def onMessage(self, msg):
        self.conversation_mgr.message_received(msg)


class PresenceHandler(PresenceClientProtocol):
    def __init__(self, conversation_mgr):
        self.conversation_mgr = conversation_mgr
        conversation_mgr.presence_protocol = self

    def subscribedReceived(self, presence):
        "Subscription approval confirmation was received."
        # This is just a confirmation. Don't respond.

        pass

    def unsubscribedReceived(self, presence):
        "Unsubscription confirmation was received."
        # This is just a confirmation. Don't respond.
        pass

    def subscribeReceived(self, entity):
        self.subscribe(entity)
        self.available(entity)

    def availableReceived(self, entity, show, statuses, priority):
        self.conversation_mgr.presence_received(entity)


class RosterHandler(RosterClientProtocol):
    def gotRoster(self, roster):
        print 'Got roster:'
        for entity, item in roster.iteritems():
            print '  %r (%r)' % (entity, item.name or '')

    def connectionInitialized(self):
        RosterClientProtocol.connectionInitialized(self)
        d = self.getRoster()
        d.addCallback(self.gotRoster)
        d.addErrback(log.err)

    def removeReceived(self, request):
        print 'Contact %r was removed.' % (request.item.entity,)

    def setReceived(self, request):
        print 'Contact %r (%r) was updated.' % (request.item.entity,
                                                request.item.name)

# }}}


def main():
    from optparse import OptionParser
    parser = OptionParser()
    parser.add_option("-j", "--jid", metavar="JID")
    parser.add_option("-p", "--password", metavar="PASSWORD")
    parser.add_option(
        "-t", "--popup-timeout", metavar="SECONDS", type="int",
        help="timeout (or 0 to disable timeout, which is the default)",
        default=0)
    parser.add_option(
        "--reg-db", metavar="SQLITE_FILE",
        help="use registration with specified database file "
        "(will be created if it does not exist)")
    parser.add_option(
        "--required-email-suffix", metavar="STRING",
        help="only allow registrations with email ending in STRING")
    options, args = parser.parse_args()

    if options.jid is None:
        raise RuntimeError("must specify JID")

    log.startLogging(sys.stdout)

    jid = JID(options.jid)

    gapp = XMPPPopupApplication()

    from twisted.internet import reactor
    reactor.registerGApplication(gapp)

    application = service.Application('XMPP client')
    xmpp_client = client.XMPPClient(jid, options.password)
    xmpp_client.logTraffic = True
    xmpp_client.setServiceParent(application)

    mshow_mgr = MessageShowManager(options)

    cmgr = ConversationManager(mshow_mgr, jid, options)

    presence = PresenceHandler(cmgr)
    presence.setHandlerParent(xmpp_client)
    presence.available()

    msg_handler = MessageReceiver(cmgr)
    msg_handler.setHandlerParent(xmpp_client)

    roster = RosterHandler()
    roster.setHandlerParent(xmpp_client)

    xmpp_client.startService()
    reactor.addSystemEventTrigger('before', 'shutdown', xmpp_client.stopService)

    from twisted.internet import reactor
    reactor.run()

if __name__ == "__main__":
    main()
